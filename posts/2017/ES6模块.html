<!doctype html><html class="" data-reactroot=""><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="前端工程师@拼多多，爱折腾，擅长 JavaScript，欢迎关注我的公众号「更了不起的前端」"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/>
<title data-react-helmet="true">【翻译】深入ES6模块 · 自然醒的博客</title>
<link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><a class="czs-menu-l show_on_mobile aside_button_open" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a><a class="show_on_mobile aside_button_text" href="/">自然醒的博客</a><aside class="hide_on_mobile"><div class="aside_card"><a class="czs-menu-l show_on_mobile aside_button_close" href="#" style="background-image:url(&quot;/assets/czs-close-l.svg&quot;)"></a><h1><a href="/">自然醒的博客</a></h1><p class="description">前端工程师@拼多多，爱折腾，擅长 JavaScript，欢迎关注我的公众号「更了不起的前端」</p><ul class="social list_style_none"><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Shenfq" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="flex_center"><a class="czs-message-l" href="mailto:shenfq95@foxmail.com" target="_blank" style="background-image:url(&quot;/assets/czs-message-l.svg&quot;)"></a></li><li style="flex-grow:1"></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul><nav><ul class="menu list_style_none"><li><a class="flex_center" href="/"><span class="czs-home-l" style="background-image:url(&quot;/assets/czs-home-l.svg&quot;)"></span>首页</a></li><li><a class="flex_center" href="/categories/"><span class="czs-category-l" style="background-image:url(&quot;/assets/czs-category-l.svg&quot;)"></span>分类</a></li><li><a class="flex_center" href="/tags/"><span class="czs-tag-l" style="background-image:url(&quot;/assets/czs-tag-l.svg&quot;)"></span>标签</a></li><li><a class="flex_center" href="/about/"><span class="czs-about-l" style="background-image:url(&quot;/assets/czs-about-l.svg&quot;)"></span>关于</a></li><li><a class="flex_center" href="/archives/"><span class="czs-box-l" style="background-image:url(&quot;/assets/czs-box-l.svg&quot;)"></span>归档</a></li><li><a class="flex_center" href="/links/index.html"><span class="czs-link-l" style="background-image:url(&quot;/assets/czs-link-l.svg&quot;)"></span>友情链接</a></li></ul></nav></div><nav class="toc"><ol><li><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">模块的基础知识</a></li><li><a href="#%E5%AF%BC%E5%87%BA%E5%88%97%E8%A1%A8">导出列表</a></li><li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5">重命名导出和导入</a></li><li><a href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AF%BC%E5%87%BA">默认的导出</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1">模块对象</a></li><li><a href="#%E8%81%9A%E5%90%88%E6%A8%A1%E5%9D%97">聚合模块</a></li><li><a href="#import%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">import到底做了什么？</a></li><li><a href="#%E9%9D%99%E6%80%81-vs-%E5%8A%A8%E6%80%81%E6%88%96%E8%80%85%E8%AF%B4%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E8%A7%84%E5%88%99">静态 VS 动态，或者说：规则如何打破规则</a></li><li><a href="#%E6%88%91%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8es6%E6%A8%A1%E5%9D%97">我什么时候才能使用ES6模块？</a></li></ol></nav></aside><section class="main"><h1>【翻译】深入ES6模块</h1><div class="main_post_meta"><time dateTime="2017/11/13">2017-11-14</time> · <!-- -->shenfq</div><article><p>回想2007年，那时候我刚加入Mozilla's JavaScript团队，那时候的一个典型的JavaScript程序只需要一行代码，听起来像个笑话。</p>
<p>两年后，Google Maps发布。在这之前，JavaScript主要用来做表单的验证，你用来处理<code>&lt;input onchange=&gt;</code>这个程序当然只需要一行。</p>
<p>时过境迁，JavaScript项目已经发展到让人叹为观止，社区涌现了许多帮助开发的工具。但是最迫切需要的是一个模块系统，它能将你的工作分散到不同的文件与目录中，在需要的时候他们能彼此之间相互访问，并且可以有效的加载所有代码。所以JavaScript有模块系统这很正常，而且还有多个模块系统（CommonJS、AMD、CMD、UMD）。不仅如此，它还有几个包管理器（npm、bower），用来安装软件还能拷贝一些深度依赖。你可能认为ES6和它的新模块系统出现得有点晚。</p>
<p>那我们来看看ES6为现存的模块系统添加了什么，以及未来的标准和工具能否建立在这个系统上。首先，让我们看看ES6的模块是什么样子的。</p>
<!-- more -->
<h2 id="%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">模块的基础知识<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">§</a></h2>
<p>ES6模块是一个包含了JS代码的文件。没有所谓的<code>module</code>关键词，一个模块看起来和一个脚本文件没什么不一样，除了一下两个区别：</p>
<ul>
<li>ES6的模块自动开启严格模式，即使你没有写<code>&quot;use strict&quot;;</code>；</li>
<li>在模块中，你可以使用<code>import</code>和<code>exprot</code>。</li>
</ul>
<p>先来谈谈export。在默认情况下，模块中所有的声明都是私有的，如果你希望模块中的某些声明是公开的，并在其他模块中使用它们，你就必须<em>导出</em>它们。这里有一些实现方法，最简单的是添加<code>export</code>关键字。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// kittydar.js - Find the locations of all the cats in an image.</span>
<span class="token comment">// (Heather Arthur wrote this library for real)</span>
<span class="token comment">// (but she didn't use modules, because it was 2013)</span>

<span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">detectCats</span><span class="token punctuation">(</span><span class="token parameter">canvas<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> kittydar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Kittydar</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword control-flow">return</span> kittydar<span class="token punctuation">.</span><span class="token method function property-access">detectCats</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name">Kittydar</span> <span class="token punctuation">{</span>
  <span class="token spread operator">...</span> several methods doing image processing <span class="token spread operator">...</span>
<span class="token punctuation">}</span>

<span class="token comment">// This helper function isn't exported.</span>
<span class="token keyword">function</span> <span class="token function">resizeCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token spread operator">...</span>
<span class="token punctuation">}</span>
<span class="token spread operator">...</span>
</code></pre>
<p>你可以<code>export</code>任何的顶级变量：<code>function</code>、<code>class</code>、<code>var</code>、<code>let</code>、<code>const</code>。</p>
<p>你如果要写一个模块知道这么多就够了！你不必再把所有的东西放到一个立即执行函数或者回调函数里面，只需要在你需要的地方进行声明。由于这个代码是一个模块，而不是一个脚本，所有的声明的作用域都只属于这个模块，而不是所有脚本和模块都能全局访问的。你只要把模块中的声明导出成一组公共模块的API就足够了。</p>
<p>除了导出，模块里的代码和其他普通代码没有什么区别。它可以访问全局变量，像<code>Object</code>和<code>Array</code>。如果你的模块在浏览器运行，还能够使用<code>document</code>和<code>XMLHttpRequest</code>。</p>
<p>在另一个文件中，我们可以导入并使用<code>detectCats()</code>函数：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// demo.js - Kittydar demo program</span>

<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>detectCats<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"kittydar.js"</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">go</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> canvas <span class="token operator">=</span> <span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token method function property-access">getElementById</span><span class="token punctuation">(</span><span class="token string">"catpix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> cats <span class="token operator">=</span> <span class="token function">detectCats</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">drawRectangles</span><span class="token punctuation">(</span>canvas<span class="token punctuation">,</span> cats<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>要从一个模块导入多个变量，你可以这样写：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>detectCats<span class="token punctuation">,</span> <span class="token maybe-class-name">Kittydar</span><span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"kittydar.js"</span><span class="token punctuation">;</span>
</code></pre>
<p>当你运行一个包含<code>import</code>声明的模块，会先导入要导入的模块并加载，然后根据深度优先的原则遍历依赖图谱来执行对应模块，并跳过已经执行的模块，来避免循环。</p>
<p>这就是模块基础知识，这真的很简单。;-)</p>
<h2 id="%E5%AF%BC%E5%87%BA%E5%88%97%E8%A1%A8">导出列表<a class="anchor" href="#%E5%AF%BC%E5%87%BA%E5%88%97%E8%A1%A8">§</a></h2>
<p>你可以把你要导出的功能名写在一个列表里，然后用大括号括起来，这样就不用在每个要导出的功能前面加上export标记。</p>
<pre class="language-javascript"><code class="language-javascript"> <span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span>detectCats<span class="token punctuation">,</span> <span class="token maybe-class-name">Kittydar</span><span class="token punctuation">}</span></span><span class="token punctuation">;</span>

<span class="token comment">// no `export` keyword required here</span>
<span class="token keyword">function</span> <span class="token function">detectCats</span><span class="token punctuation">(</span><span class="token parameter">canvas<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Kittydar</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>
</code></pre>
<p>导出列表并不需要写在文件的第一行，它可以出现在模块文件的顶级作用域的任何位置。你可以有多个导出列表，或者将导出列表与导出声明混合使用，只要不重复导出同一个变量名就行。</p>
<h2 id="%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5">重命名导出和导入<a class="anchor" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5">§</a></h2>
<p>有时，导入的变量名碰巧与你需要使用的一些变量名冲突了，ES6允许你重命名导入的变量。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// suburbia.js</span>

<span class="token comment">// Both these modules export something named `flip`.</span>
<span class="token comment">// To import them both, we must rename at least one.</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>flip <span class="token keyword module">as</span> flipOmelet<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"eggs.js"</span><span class="token punctuation">;</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>flip <span class="token keyword module">as</span> flipHouse<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"real-estate.js"</span><span class="token punctuation">;</span>
<span class="token spread operator">...</span>
</code></pre>
<p>同样，你在导出变量的时候也可以重命名它们。这在你想使用不同名字导出相同功能的时候十分方便。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// unlicensed_nuclear_accelerator.js - media streaming without drm</span>
<span class="token comment">// (not a real library, but maybe it should be)</span>

<span class="token keyword">function</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span>
  v1 <span class="token keyword module">as</span> streamV1<span class="token punctuation">,</span>
  v2 <span class="token keyword module">as</span> streamV2<span class="token punctuation">,</span>
  v2 <span class="token keyword module">as</span> streamLatestVersion
<span class="token punctuation">}</span></span><span class="token punctuation">;</span>
</code></pre>
<h2 id="%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AF%BC%E5%87%BA">默认的导出<a class="anchor" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%AF%BC%E5%87%BA">§</a></h2>
<p>新的标准在设计上是兼容已经存在的CommonJS和AMD模块的。如果你有一个Node项目，并且你已经执行了<code>npm install lodash</code>。你使用ES6代码能够单独引入Lodash中的函数：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span>each<span class="token punctuation">,</span> map<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"lodash"</span><span class="token punctuation">;</span>

<span class="token function">each</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token parameter">x</span> <span class="token arrow operator">=></span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>如果你已经习惯使用<code>_.each</code>而不是<code>each</code>，你依然想像以前一样使用它。或者， 你想把<code>_</code>当成一个函数来使用，因为这才是Lodash。</p>
<p>这种情况下，你只要稍微改变下你的写法：不使用花括号来导入模块。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword module">import</span> <span class="token imports">_</span> <span class="token keyword module">from</span> <span class="token string">"lodash"</span><span class="token punctuation">;</span>
</code></pre>
<p>这个写法等同于<code> import {default as _} from &quot;lodash&quot;;</code>。所有的CommonJS 和AMD模块在ES6中都能被当作<code>default</code>导出，这个导出和你在CommonJS中使用<code>require()</code>导出得到东西一样，即<code>exports</code>对象。</p>
<p>ES6模块在设计上可以让你导出更多的东西，但对于现在的CommonJS模块，导出的default模块就是能导出的全部东西了。例如，在写这篇文章时，据我所知，著名的<a href="https://github.com/Marak/colors.js">colors模块</a>没有特意去支持ES6语法，这是一个CommonJS模块组成的包，就像npm上的那些包一样，但是你可以直接引入到你的ES6代码中。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// ES6 equivalent of `var colors = require("colors/safe");`</span>
<span class="token keyword module">import</span> <span class="token imports">colors</span> <span class="token keyword module">from</span> <span class="token string">"colors/safe"</span><span class="token punctuation">;</span>
</code></pre>
<p>如果你希望自己ES6模块也具有默认导出，这很简单。默认的导出方式并没有什么魔力；他就像其他导出一样，除了它的导出名为<code>default</code>。你可以使用我们之前提到的重命名语法：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  field1<span class="token operator">:</span> value1<span class="token punctuation">,</span>
  field2<span class="token operator">:</span> value2
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span>myObject <span class="token keyword module">as</span> <span class="token keyword module">default</span><span class="token punctuation">}</span></span><span class="token punctuation">;</span>
</code></pre>
<p>或者使用简写：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>
  field1<span class="token operator">:</span> value1<span class="token punctuation">,</span>
  field2<span class="token operator">:</span> value2
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p><code>export default</code>关键词后面可以跟任何值：一个函数、一个类、一个对象，所有能被命名的变量。</p>
<h2 id="%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1">模块对象<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1">§</a></h2>
<p>不好意思，这篇文章有点长。JavaScript并不孤独：因为一些原因，所有的语言中都有模块系统，并且倾向于设计大量杂乱而又无聊的小特性。幸运的是我们只剩下一个话题，噢，不对，是两个。</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> cows</span> <span class="token keyword module">from</span> <span class="token string">"cows"</span><span class="token punctuation">;</span>
</code></pre>
<p>当你使用<code>import *</code>的时候，被引入的是一个模块命名空间对象（module namespace object），它的属性是模块的输出。如果“cows”模块导出一个名为moo()的函数，那么在导入“cows”之后，你可以使用<code>cows.moo()</code>来进行调用。</p>
<h2 id="%E8%81%9A%E5%90%88%E6%A8%A1%E5%9D%97">聚合模块<a class="anchor" href="#%E8%81%9A%E5%90%88%E6%A8%A1%E5%9D%97">§</a></h2>
<p>有时候一个包的主模块只不过是导入包其他所有的模块，并用统一的方式导出。为了简化这种代码，有一种将导入导出全部合一的简写：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// world-foods.js - good stuff from all over</span>

<span class="token comment">// import "sri-lanka" and re-export some of its exports</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span><span class="token maybe-class-name">Tea</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Cinnamon</span><span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"sri-lanka"</span><span class="token punctuation">;</span>

<span class="token comment">// import "equatorial-guinea" and re-export some of its exports</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span><span class="token maybe-class-name">Coffee</span><span class="token punctuation">,</span> <span class="token maybe-class-name">Cocoa</span><span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">"equatorial-guinea"</span><span class="token punctuation">;</span>

<span class="token comment">// import "singapore" and export ALL of its exports</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token operator">*</span></span> <span class="token keyword module">from</span> <span class="token string">"singapore"</span><span class="token punctuation">;</span>
</code></pre>
<p>这种<code>export-from</code>表达式类似于<code>import-from</code>后面跟了一个<code>export</code>。这和真正的导入有一些区别，它不会在当前作用域中绑定将要导出的变量。如果你打算在<code>world-foods.js</code>中使用<code>Tea</code>来编写一些代码，请不要使用这种简写，你会发现Tea为定义。</p>
<p>如果“singapore”导出的命名与其他导出发生了冲突，那就会出现错误，所以请谨慎使用。</p>
<p>呼，我们已经把语法介绍完了！下面来谈谈一些有趣的事情。</p>
<h2 id="import%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">import到底做了什么？<a class="anchor" href="#import%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">§</a></h2>
<p>不管你信不信，它什么都没做。</p>
<p>噢，你看起来没那么好骗。那么你会相信标准几乎没有说<code>import</code>到底该怎么做吗？这是件好事吗？（作者貌似很爱开玩笑。）</p>
<p>ES6将模块的加载细节<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-hostresolveimportedmodule">完全交给了实现</a>，其余的模块执行部分却<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-toplevelmoduleevaluationjob">规定得非常详细</a>。</p>
<p>简单来说，当你告诉JS引擎运行一个模块的时候，它的行为可以归纳为以下四部：</p>
<ol>
<li>解析：读取模块的源代码，并检查语法错误。</li>
<li>加载：加载所有的导入模块（递归进行），这是还未标准化的部分。</li>
<li>链接：对于每个新加载的模块，在实现上都会创建一个作用域，并把模块中声明的所有变量都绑定在这个作用域上，包括从其他模块导入的变量。
如果你想试试<code>import {cake} from &quot;paleo&quot;</code>，但是“paleo”模块没真正导出名为cake的变量，你会得到一个错误。这很糟糕，因为你离运行js并品尝蛋糕只有一步之遥。</li>
<li>运行时间：最后，开始执行加载进来的新的模块中的代码。这时，整个<code>import</code>过程已经完成了，所以前面说代码执行到<code>import</code>这一行声明时，什么都没有发生。</li>
</ol>
<p>看到没？我说了什么都不会发生，在编程语言这件事上，我从来都不说慌。</p>
<p>现在我们可以开始介绍这个系统中有趣的部分了。这有一个非常炫酷的技巧。由于系统没有指定如何加载的这方面的细节，并且你可以通过查看源代码中导入的声明，提前计算出所有的依赖项，所以ES6的实现可以通过预处理器完成所有的工作，然后把所有的模块打包到一个文件中，最后通过网络进行请求一次即可。像webpack这样的工具就是这么做的。</p>
<p>这是一个优雅的解决方案，因为通过网络加载所有的脚本文件很耗时，假如你请求一个资源后，发现里面有<code>import</code>声明，然后你又得请求更多资源。一个加载器需要非常多的网络请求来回传输。通过webpack，你不仅能在今天就使用ES6的模块话，你还能获得很多好处，并且不需要担心会造成运行时的性能下降。</p>
<p>原本是有计划制定一个ES6中模块加载的详细规范的，并且已经初步成型。它没有成为标准的原因之一是不知道如何与打包这一特性进行整合。我希望模块化的加载会更加标准化，也希望打包工具会越来越好。</p>
<h2 id="%E9%9D%99%E6%80%81-vs-%E5%8A%A8%E6%80%81%E6%88%96%E8%80%85%E8%AF%B4%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E8%A7%84%E5%88%99">静态 VS 动态，或者说：规则如何打破规则<a class="anchor" href="#%E9%9D%99%E6%80%81-vs-%E5%8A%A8%E6%80%81%E6%88%96%E8%80%85%E8%AF%B4%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E8%A7%84%E5%88%99">§</a></h2>
<p>作为一个动态编译语言，令人惊奇的是JavaScript拥有一个静态的模块系统。</p>
<ul>
<li>所有的<code>import</code>和<code>export</code>只能写在顶级作用域中。你不能在条件判断语句和函数作用域内使用<code>import</code>。</li>
<li>所有导出的变量名必须是显式的，你不能通过遍历一个数组，动态生成一组导出名进行导出。</li>
<li>模块对象都是被冻结的，不能通过polyfill为它添加新的特性。</li>
<li>在所有模块运行之前， 其依赖的模块都必须经过加载、解析、链接的过程，目前没有<code>import</code>懒加载相关的语法。（现在import()方法已经在提案中了）</li>
<li>对于<code>import</code>的错误，无法进行recovery。一个应用可能依赖许多的模块，一旦有一个模块加载失败，这个应用都不会运行。你不能在<code>try/catch</code>中使用<code>import</code>。正是因为es6的模块表现得如此静态，webpack才能在编译的时候检测出代码中的错误。</li>
<li>你没法为一个模块在加载所有依赖项之前添加钩子，这意味着一个模块没有办法控制其依赖项的加载方式。</li>
</ul>
<p>如果你的需求是静态的，ES6的模块系统还是相当不错的。但是你有时候你还是向进行一些hack，对吧？</p>
<p>这就是为什么你使用的模块加载系统会提供一些系统层次的API来配合ES6的静态的<code>import/export</code>语法。例如，webpack有一个API能进行代码的分割，按照你的需求对一些模块进行懒加载。这个API能够打破之前列出的规矩。</p>
<p>ES6的模块语法非常静态，这很好-在使用一些编译工具时我们都能尝到一些甜头。
静态语法的设计可以让它与动态加载器丰富的API进行工作。</p>
<h2 id="%E6%88%91%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8es6%E6%A8%A1%E5%9D%97">我什么时候才能使用ES6模块？<a class="anchor" href="#%E6%88%91%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8es6%E6%A8%A1%E5%9D%97">§</a></h2>
<p>如果你今天就想使用，你需要一个预编译器，如 <a href="https://github.com/google/traceur-compiler#what-is-traceur">Traceur</a> 和 <a href="http://babeljs.io/">Babel</a> 。这个系列之前也有相关文章，<a href="https://hacks.mozilla.org/2015/06/es6-in-depth-babel-and-broccoli/">Gastón I. Silva：如何使用 Babel 和 Broccoli</a> 编译 ES6 代码为 web 可用。Gastón也将案例<a href="https://github.com/givanse/broccoli-babel-examples/tree/master/es6-modules">放在了 GitHub 上</a>。另外<a href="http://2ality.com/2015/04/webpack-es6.html">这篇文章</a>也介绍了如何使用 Babel 和 webpack。</p>
<p>ES6 模块系统由 Dave Herman 和 Sam Tobin-Hochstadt进行设计，他们不顾多人（包括我）的反对，多年来始终坚持模块系统是静态的。JonCoppeard正在Firefox上实现ES6的模块化功能。JavaScript Loader的相关标准的工作也正在进行中，预计在HTML中将会被添加类似<code>&lt;script type=module&gt;</code> 这样的东西。</p>
<p>这便是 ES6 了。</p>
<p>这太有趣了，我不希望现在就结束。也许我们还能再说一会。我们还能够讨论一些关于ES6规范中零零碎碎的东西，但这些又不足够写成文章。也行会有一些关于ES6未来特性的一些东西，尽请期待下周的<code>ES6 In Depth</code>。</p>
<hr>
<p>原文链接：<a href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">ES6 In Depth: Modules</a></p></article></section><footer>Powered by <a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>