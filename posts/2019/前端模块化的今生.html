<!doctype html><html class="" data-reactroot=""><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="前端工程师@拼多多，爱折腾，擅长 JavaScript，欢迎关注我的公众号「更了不起的前端」"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/>
<title data-react-helmet="true">前端模块化的今生 · 自然醒的博客</title>
<link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><a class="czs-menu-l show_on_mobile aside_button_open" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a><a class="show_on_mobile aside_button_text" href="/">自然醒的博客</a><aside class="hide_on_mobile"><a class="czs-menu-l show_on_mobile aside_button_close" href="#" style="background-image:url(&quot;/assets/czs-close-l.svg&quot;)"></a><h1><a href="/">自然醒的博客</a></h1><p class="description">前端工程师@拼多多，爱折腾，擅长 JavaScript，欢迎关注我的公众号「更了不起的前端」</p><ul class="social list_style_none"><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Shenfq" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="flex_center"><a class="czs-message-l" href="mailto:shenfq95@foxmail.com" target="_blank" style="background-image:url(&quot;/assets/czs-message-l.svg&quot;)"></a></li><li style="flex-grow:1"></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul><nav><ul class="menu list_style_none"><li><a class="flex_center" href="/"><span class="czs-home-l" style="background-image:url(&quot;/assets/czs-home-l.svg&quot;)"></span>首页</a></li><li><a class="flex_center" href="/categories/"><span class="czs-category-l" style="background-image:url(&quot;/assets/czs-category-l.svg&quot;)"></span>分类</a></li><li><a class="flex_center" href="/tags/"><span class="czs-tag-l" style="background-image:url(&quot;/assets/czs-tag-l.svg&quot;)"></span>标签</a></li><li><a class="flex_center" href="/about/"><span class="czs-about-l" style="background-image:url(&quot;/assets/czs-about-l.svg&quot;)"></span>关于</a></li><li><a class="flex_center" href="/archives/"><span class="czs-box-l" style="background-image:url(&quot;/assets/czs-box-l.svg&quot;)"></span>归档</a></li><li><a class="flex_center" href="/links/index.html"><span class="czs-link-l" style="background-image:url(&quot;/assets/czs-link-l.svg&quot;)"></span>友情链接</a></li></ul></nav></aside><section class="main"><h1>前端模块化的今生</h1><div class="main_post_meta"><time dateTime="2019/11/30">2019-11-31</time> · <!-- -->shenfq</div><article><h2 id="%E8%83%8C%E6%99%AF">背景<a class="anchor" href="#%E8%83%8C%E6%99%AF">§</a></h2>
<p>众所周知，早期 JavaScript 原生并不支持模块化，直到 2015 年，TC39 发布 ES6，其中有一个规范就是 <code>ES modules</code>（为了方便表述，后面统一简称 ESM）。但是在 ES6 规范提出前，就已经存在了一些模块化方案，比如 CommonJS（in Node.js）、AMD。ESM 与这些规范的共同点就是都支持导入（import）和导出（export）语法，只是其行为的关键词也一些差异。</p>
<h4 id="commonjs">CommonJS<a class="anchor" href="#commonjs">§</a></h4>
<pre class="language-js"><code class="language-js"><span class="token comment">// add.js</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> a <span class="token operator">+</span> b
module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> add
<span class="token comment">// index.js</span>
<span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./add'</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
</code></pre>
<h4 id="amd">AMD<a class="anchor" href="#amd">§</a></h4>
<pre class="language-js"><code class="language-js"><span class="token comment">// add.js</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> a <span class="token operator">+</span> b
  <span class="token keyword control-flow">return</span> add
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// index.js</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./add'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">add</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h4 id="esm">ESM<a class="anchor" href="#esm">§</a></h4>
<pre class="language-js"><code class="language-js"><span class="token comment">// add.js</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> a <span class="token operator">+</span> b
<span class="token keyword module">export</span> <span class="token keyword module">default</span> add
<span class="token comment">//index.js</span>
<span class="token keyword module">import</span> <span class="token imports">add</span> <span class="token keyword module">from</span> <span class="token string">'./add'</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>

</code></pre>
<p>关于 JavaScript 模块化出现的背景在上一章（<a href="https://blog.shenfq.com/2019/ck2lcgcxq001u2ise7lmss6zw/">《前端模块化的前世》</a>）已经有所介绍，这里不再赘述。但是 ESM 的出现不同于其他的规范，因为这是 JavaScript 官方推出的模块化方案，相比于 CommonJS 和 AMD 方案，ESM采用了完全静态化的方式进行模块的加载。</p>
<h2 id="esm%E8%A7%84%E8%8C%83">ESM规范<a class="anchor" href="#esm%E8%A7%84%E8%8C%83">§</a></h2>
<h3 id="%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA">模块导出<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%87%BA">§</a></h3>
<p>模块导出只有一个关键词：<code>export</code>，最简单的方法就是在声明的变量前面直接加上 export 关键词。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
</code></pre>
<p>可以在 const、let、var 前直接加上 export，也可以在 function 或者 class 前面直接加上 export。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> name
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
	<span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter"><span class="token spread operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面的导出方法也可以使用大括号的方式进行简写。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> name
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
	<span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter"><span class="token spread operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token spread operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName<span class="token punctuation">,</span> <span class="token maybe-class-name">Logger</span> <span class="token punctuation">}</span></span>
</code></pre>
<p>最后一种语法，也是我们经常使用的，导出默认模块。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> name
</code></pre>
<h3 id="%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5">模块导入<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5">§</a></h3>
<p>模块的导入使用<code>import</code>，并配合 <code>from</code> 关键词。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token imports">name</span> <span class="token keyword module">from</span> <span class="token string">'./module.js'</span>

<span class="token comment">// module.js</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> name
</code></pre>
<p>这样直接导入的方式，<code>module.js</code> 中必须使用 <code>export default</code>，也就是说 import 语法，默认导入的是<code>default</code>模块。如果想要导入其他模块，就必须使用对象展开的语法。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./module.js'</span>

<span class="token comment">// module.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> name
</code></pre>
<p>如果模块文件同时导出了默认模块，和其他模块，在导入时，也可以同时将两者导入。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token imports">name<span class="token punctuation">,</span> <span class="token punctuation">{</span> getName <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./module.js'</span>

<span class="token comment">//module.js</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> name
<span class="token keyword module">export</span> <span class="token keyword module">default</span> name
</code></pre>
<p>当然，ESM 也提供了重命名的语法，将导入的模块进行重新命名。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token operator">*</span> <span class="token keyword module">as</span> mod</span> <span class="token keyword module">from</span> <span class="token string">'./module.js'</span>
<span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">''</span>
name <span class="token operator">=</span> mod<span class="token punctuation">.</span><span class="token property-access">name</span>
name <span class="token operator">=</span> mod<span class="token punctuation">.</span><span class="token method function property-access">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// module.js</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shenfq'</span>
<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> name
</code></pre>
<p>上述写法就相当于于将模块导出的对象进行重新赋值：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./module.js'</span>
<span class="token keyword">const</span> mod <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span>
</code></pre>
<p>同时也可以对单独的变量进行重命名：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// main.js</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token keyword module">as</span> getModName <span class="token punctuation">}</span>
</code></pre>
<h3 id="%E5%AF%BC%E5%85%A5%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%AF%BC%E5%87%BA">导入同时进行导出<a class="anchor" href="#%E5%AF%BC%E5%85%A5%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%AF%BC%E5%87%BA">§</a></h3>
<p>如果有两个模块 a 和 b ，同时引入了模块 c，但是这两个模块还需要导入模块 d，如果模块 a、b 在导入 c 之后，再导入 d 也是可以的，但是有些繁琐，我们可以直接在模块 c 里面导入模块 d，再把模块 d 暴露出去。</p>
<p><img src="https://file.shenfq.com/zbsq0.png" alt="模块关系"></p>
<pre class="language-js"><code class="language-js"><span class="token comment">// module_c.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./module_d.js'</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span></span>
</code></pre>
<p>这么写看起来还是有些麻烦，这里 ESM 提供了一种将 import 和 export 进行结合的语法。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> getName <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./module_d.js'</span>
</code></pre>
<p>上面是 ESM 规范的一些基本语法，如果想了解更多，可以翻阅阮老师的 <a href="http://es6.ruanyifeng.com/#docs/module">《ES6 入门》</a>。</p>
<h3 id="esm-%E4%B8%8E-commonjs-%E7%9A%84%E5%B7%AE%E5%BC%82">ESM 与 CommonJS 的差异<a class="anchor" href="#esm-%E4%B8%8E-commonjs-%E7%9A%84%E5%B7%AE%E5%BC%82">§</a></h3>
<p>首先肯定是语法上的差异，前面也已经简单介绍过了，一个使用 <code>import/export</code> 语法，一个使用 <code>require/module</code> 语法。</p>
<p>另一个 ESM 与 CommonJS 显著的差异在于，ESM 导入模块的变量都是强绑定，导出模块的变量一旦发生变化，对应导入模块的变量也会跟随变化，而 CommonJS 中导入的模块都是值传递与引用传递，类似于函数传参（基本类型进行值传递，相当于拷贝变量，非基础类型【对象、数组】，进行引用传递）。</p>
<p>下面我们看下详细的案例：</p>
<p><strong>CommonJS</strong></p>
<pre class="language-js"><code class="language-js"><span class="token comment">// a.js</span>
<span class="token keyword">const</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>

<span class="token comment">// b.js</span>
<span class="token keyword">let</span> mod <span class="token operator">=</span> <span class="token string">'first value'</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  mod <span class="token operator">=</span> <span class="token string">'second value'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>

module<span class="token punctuation">.</span><span class="token property-access">exports</span> <span class="token operator">=</span> mod
</code></pre>
<pre class="language-bash"><code class="language-bash">$ node a.js
first value
</code></pre>
<p><strong>ESM</strong></p>
<pre class="language-js"><code class="language-js"><span class="token comment">// a.mjs</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mod <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'./b.mjs'</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>

<span class="token comment">// b.mjs</span>
<span class="token keyword module">export</span> <span class="token keyword">let</span> mod <span class="token operator">=</span> <span class="token string">'first value'</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  mod <span class="token operator">=</span> <span class="token string">'second value'</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
</code></pre>
<pre class="language-bash"><code class="language-bash">$ node --experimental-modules a.mjs
<span class="token comment"># (node:99615) ExperimentalWarning: The ESM module loader is experimental.</span>
second value
</code></pre>
<p>另外，CommonJS 的模块实现，实际是给每个模块文件做了一层函数包裹，从而使得每个模块获取 <code>require/module</code>、<code>__filename/__dirname</code> 变量。那上面的 <code>a.js</code> 来举例，实际执行过程中 <code>a.js</code> 运行代码如下：</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// a.js</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>而 ESM 的模块是通过 <code>import/export</code> 关键词来实现，没有对应的函数包裹，所以在 ESM 模块中，需要使用 <code>import.meta</code> 变量来获取 <code>__filename/__dirname</code>。<code>import.meta</code> 是 ECMAScript 实现的一个包含模块元数据的特定对象，主要用于存放模块的 <code>url</code>，而 node 中只支持加载本地模块，所以 url 都是使用 <code>file:</code> 协议。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports">url</span> <span class="token keyword module">from</span> <span class="token string">'url'</span>
<span class="token keyword module">import</span> <span class="token imports">path</span> <span class="token keyword module">from</span> <span class="token string">'path'</span>
<span class="token comment">// import.meta: { url: <a class="token url-link" href="file:///Users/dev/mjs/a.mjs">file:///Users/dev/mjs/a.mjs</a> }</span>
<span class="token keyword">const</span> __filename <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token method function property-access">fileURLToPath</span><span class="token punctuation">(</span><span class="token keyword module">import</span><span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> __dirname <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token method function property-access">dirname</span><span class="token punctuation">(</span>__filename<span class="token punctuation">)</span>
</code></pre>
<h2 id="%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86">加载的原理<a class="anchor" href="#%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86">§</a></h2>
<p>步骤：</p>
<ol>
<li>Construction（构造）：下载所有的文件并且解析为module records。</li>
<li>Instantiation（实例）：把所有导出的变量入内存指定位置（但是暂时还不求值）。然后，让导出和导入都指向内存指定位置。这叫做『linking(链接)』。</li>
<li>Evaluation（求值）：执行代码，得到变量的值然后放到内存对应位置。</li>
</ol>
<h3 id="%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95">模块记录<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95">§</a></h3>
<p>所有的模块化开发，都是从一个入口文件开始，无论是 Node.js 还是浏览器，都会根据这个入口文件进行检索，一步一步找到其他所有的依赖文件。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Node.js: main.mjs</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Log</span></span> <span class="token keyword module">from</span> <span class="token string">'./log.mjs'</span>
</code></pre>
<pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- chrome、firefox --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./log.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>值得注意的是，刚开始拿到入口文件，我们并不知道它依赖了哪些模块，所以必须先通过 js 引擎静态分析，得到一个模块记录，该记录包含了该文件的依赖项。所以，一开始拿到的 js 文件并不会执行，只是会将文件转换得到一个模块记录（module records）。所有的 import 模块都在模块记录的 <code>importEntries</code> 字段中记录，更多模块记录相关的字段可以查阅<a href="https://tc39.es/ecma262/#table-38">tc39.es</a>。</p>
<p><img src="https://file.shenfq.com/r50gc.png" alt="模块记录"></p>
<h3 id="%E6%A8%A1%E5%9D%97%E6%9E%84%E9%80%A0">模块构造<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E6%9E%84%E9%80%A0">§</a></h3>
<p>得到模块记录后，会下载所有依赖，并再次将依赖文件转换为模块记录，一直持续到没有依赖文件为止，这个过程被称为『构造』（construction）。</p>
<p>模块构造包括如下三个步骤：</p>
<ol>
<li>模块识别（解析依赖模块 url，找到真实的下载路径）；</li>
<li>文件下载（从指定的 url 进行下载，或从文件系统进行加载）；</li>
<li>转化为模块记录（module records）。</li>
</ol>
<p>对于如何将模块文件转化为模块记录，ESM 规范有详细的说明，但是在构造这个步骤中，要怎么下载得到这些依赖的模块文件，在 ESM 规范中并没有对应的说明。因为如何下载文件，在服务端和客户端都有不同的实现规范。比如，在浏览器中，如何下载文件是属于 HTML 规范（浏览器的模块加载都是使用的 script 标签）。</p>
<p>虽然下载完全不属于 ESM 的现有规范，但在 <code>import</code> 语句中还有一个引用模块的 url 地址，关于这个地址需要如何转化，在 Node 和浏览器之间有会出现一些差异。简单来说，在 Node 中可以直接 import 在 node_modules 中的模块，而在浏览器中并不能直接这么做，因为浏览器无法正确的找到服务器上的 node_modules 目录在哪里。好在有一个叫做 <a href="https://github.com/WICG/import-maps">import-maps</a> 的提案，该提案主要就是用来解决浏览器无法直接导入模块标识符的问题。但是，在该提案未被完全实现之前，浏览器中依然只能使用 url 进行模块导入。</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>importmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token punctuation">{</span>
  <span class="token string">"imports"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  	<span class="token string">"jQuery"</span><span class="token operator">:</span> <span class="token string">"/node_modules/jquery/dist/jquery.js"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
	<span class="token keyword module">import</span> <span class="token imports">$</span> <span class="token keyword module">from</span> <span class="token string">'jQuery'</span>
  <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">html</span><span class="token punctuation">(</span><span class="token string">'init'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>下载好的模块，都会被转化为模块记录然后缓存到 <code>module map</code> 中，遇到不同文件获取的相同依赖，都会直接在 <code>module map</code> 缓存中获取。</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// log.js</span>
<span class="token keyword">const</span> log <span class="token operator">=</span> <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token property-access">log</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> log

<span class="token comment">// file.js</span>
<span class="token keyword module">export</span> <span class="token exports"><span class="token punctuation">{</span> 
  readFileSync <span class="token keyword module">as</span> read<span class="token punctuation">,</span>
  writeFileSync <span class="token keyword module">as</span> write
<span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">'fs'</span>
</code></pre>
<p><img src="https://file.shenfq.com/3u8rz.png" alt="module map"></p>
<h3 id="%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B">模块实例<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%AE%9E%E4%BE%8B">§</a></h3>
<p>获取到所有依赖文件并建立好 <code>module map</code> 后，就会找到所有模块记录，并取出其中的所有导出的变量，然后，将所有变量一一对应到内存中，将对应关系存储到『模块环境记录』（module environment record）中。当然当前内存中的变量并没有值，只是初始化了对应关系。初始化导出变量和内存的对应关系后，紧接着会设置模块导入和内存的对应关系，确保相同变量的导入和导出都指向了同一个内存区域，并保证所有的导入都能找到对应的导出。</p>
<p><img src="https://file.shenfq.com/754dc.png" alt="模块连接"></p>
<p>由于导入和导出指向同一内存区域，所以导出值一旦发生变化，导入值也会变化，不同于 CommonJS，CommonJS 的所有值都是基于拷贝的。连接到导入导出变量后，我们就需要将对应的值放入到内存中，下面就要进入到求值的步骤了。</p>
<h3 id="%E6%A8%A1%E5%9D%97%E6%B1%82%E5%80%BC">模块求值<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E6%B1%82%E5%80%BC">§</a></h3>
<p>求值步骤相对简单，只要运行代码把计算出来的值填入之前记录的内存地址就可以了。到这里就已经能够愉快的使用 ESM 模块化了。</p>
<h2 id="esm%E7%9A%84%E8%BF%9B%E5%B1%95">ESM的进展<a class="anchor" href="#esm%E7%9A%84%E8%BF%9B%E5%B1%95">§</a></h2>
<p>因为 ESM 出现较晚，服务端已有 CommonJS 方案，客户端又有 webpack 打包工具，所以 ESM 的推广不得不说还是十分艰难的。</p>
<h3 id="%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端<a class="anchor" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">§</a></h3>
<p>我们先看看客户端的支持情况，这里推荐大家到 <a href="https://caniuse.com/#feat=es6-module">Can I Use</a> 直接查看，下图是 <code>2019/11</code>的截图。</p>
<p><img src="https://file.shenfq.com/wle9v.png" alt="Can I use"></p>
<p>目前为止，主流浏览器都已经支持 ESM 了，只需在 <code>script</code> 标签传入指定的 <code>type=&quot;module&quot;</code> 即可。</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>另外，我们知道在 Node.js 中，要使用 ESM 有时候需要用到 .mjs 后缀，但是浏览器并不关心文件后缀，只需要 http 响应头的MIME类型正确即可（<code>Content-Type: text/javascript</code>）。同时，当 <code>type=&quot;module&quot;</code> 时，默认启用 <code>defer</code> 来加载脚本。这里补充一张 defer、async 差异图。</p>
<p><img src="https://file.shenfq.com/cfnmx.png" alt="img"></p>
<p>我们知道浏览器不支持 <code>script</code> 的时候，提供了 <code>noscript</code> 标签用于降级处理，模块化也提供了类似的标签。</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">nomodule</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'当前浏览器不支持 ESM ！！！'</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<p>这样我们就能针对支持 ESM 的浏览器直接使用模块化方案加载文件，不支持的浏览器还是使用 webpack 打包的版本。</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./src/main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">nomodule</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./dist/app.[hash].js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载<a class="anchor" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">§</a></h4>
<p>我们知道浏览器的 link 标签可以用作资源的预加载，比如我需要预先加载 <code>main.js</code> 文件：</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>link</span><span class="token punctuation">></span></span>
</code></pre>
<p>如果这个 <code>main.js</code> 文件是一个模块化文件，浏览器仅仅预先加载单独这一个文件是没有意义的，前面我们也说过，一个模块化文件下载后还需要转化得到模块记录，进行模块实例、模块求值这些操作，所以我们得想办法告诉浏览器，这个文件是一个模块化的文件，所以浏览器提供了一种新的 rel 类型，专门用于模块化文件的预加载。</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>modulepreload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./main.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>link</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="%E7%8E%B0%E7%8A%B6">现状<a class="anchor" href="#%E7%8E%B0%E7%8A%B6">§</a></h4>
<p>虽然主流浏览器都已经支持了 ESM，但是根据 <a href="https://www.chromestatus.com/metrics/feature/timeline/popularity/2062">chrome 的统计</a>，有用到 <code>&lt;script type=&quot;module&quot;&gt;</code> 的页面只有 1%。截图时间为 <code>2019/11</code>。</p>
<p><img src="https://file.shenfq.com/47tn2.png" alt="统计"></p>
<h3 id="%E6%9C%8D%E5%8A%A1%E7%AB%AF">服务端<a class="anchor" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF">§</a></h3>
<p>浏览器能够通过 script 标签指定当前脚本是否作为模块处理，但是在 Node.js 中没有很明确的方式来表示是否需要使用 ESM，而且 Node.js 中本身就已经有了 CommonJS 的标准模块化方案。就算开启了 ESM，又通过何种方式来判断当前入口文件导入的模块到底是使用的 ESM 还是 CommonJS 呢？为了解决上述问题，node 社区开始出现了 ESM 的相关草案，具体可以在 <a href="https://github.com/nodejs/node-eps/blob/master/002-es-modules.md">github</a> 上查阅。</p>
<p>2017年发布的 Node.js 8.5.0 开启了 ESM 的实验性支持，在启动程序时，加上 <code>--experimental-modules</code> 来开启对 ESM 的支持，并将 <code>.mjs</code> 后缀的文件当做 ESM 来解析。早期的期望是在 Node.js 12 达到 LTS 状态正式发布，然后期望并没有实现，直到最近的 13.2.0 版本才正式支持 ESM，也就是取消了 <code>--experimental-modules</code> 启动参数。具体细节可以查看 Node.js 13.2.0 的<a href="https://nodejs.org/api/esm.html#esm_ecmascript_modules">官方文档</a>。</p>
<p>关于 <code>.mjs</code> 后缀社区有两种完全不同的态度。支持的一方认为通过文件后缀区分类型是最简单也是最明确的方式，且社区早已有类似案例，例如，<code>.jsx</code> 用于 React 组件、<code>.ts</code> 用于 ts 文件；而支持的一方认为，<code>.js</code> 作为 js 后缀已经存在这么多年，视觉上很难接受一个 <code>.mjs</code> 也是 js 文件，而且现有的很多工具都是以 <code>.js</code> 后缀来识别 js 文件，如果引入了 <code>.mjs</code> 方案，就有大批量的工具需要修改来有效的适配 ESM。</p>
<p>所以除了 <code>.mjs</code> 后缀指定 ESM 外，还可以使用 <code>pkg.json</code> 文件的 <code>type</code> 属性。如果 type 属性为 module，则表示当前模块应使用 ESM 来解析模块，否则使用 CommonJS 解析模块。</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"module"</span> <span class="token comment">// module | commonjs(default)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>当然有些本地文件是没有 <code>pkg.json</code> 的，但是你又不想使用 <code>.mjs</code> 后缀，这时候只需要在命令行加上一个启动参数 <code>--input-type=module</code>。同时 <code>input-type</code> 也支持 commonjs 参数来指定使用 CommonJS（<code>-—input-type=commonjs</code>）。</p>
<p>总结一下，Node.js 中，以下三种情况会启用 ESM 的模块加载方式：</p>
<ol>
<li>文件后缀为<code>.mjs</code>;</li>
<li><code>pkg.json</code> 中 type 字段指定为 <code>module</code>；</li>
<li>启动参数添加 <code>--input-type=module</code>。</li>
</ol>
<p>同样，也有三种情况会启用 CommonJS 的模块加载方式：</p>
<ol>
<li>文件后缀为<code>.cjs</code>;</li>
<li><code>pkg.json</code> 中 type 字段指定为 <code>commonjs</code>；</li>
<li>启动参数添加 <code>--input-type=commonjs</code>。</li>
</ol>
<p>虽然 13.2 版本去除了 <code>--experimental-modules</code> 的启动参数，但是按照文档的说法，在 Node.js 中使用 ESM 依旧是实验特性。</p>
<blockquote>
<p><a href="https://nodejs.org/api/documentation.html#documentation_stability_index">Stability: 1</a> - Experimental</p>
</blockquote>
<p>不过，相信等到 Node.js 14 LTS 版本发布时，ESM 的支持应该就能进入稳定阶段了，这里还有一个 Node.js 关于 ESM 的整个<a href="https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md">计划列表</a>可以查阅。</p>
<h2 id="%E5%8F%82%E8%80%83">参考<a class="anchor" href="#%E5%8F%82%E8%80%83">§</a></h2>
<ul>
<li><a href="https://github.com/nodejs/modules/">nodejs/modules</a></li>
<li><a href="https://2ality.com/2017/05/es-module-specifiers.html">Module specifiers: what’s new with ES modules?</a></li>
<li><a href="https://segmentfault.com/a/1190000014318751">图说 ES Modules</a>（<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES modules: A cartoon deep-dive</a>）</li>
</ul></article></section><footer>Powered by <a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>