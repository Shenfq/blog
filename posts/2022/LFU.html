<!doctype html><html class="" data-reactroot=""><head><script src="/assets/hm.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"/>
<meta data-react-helmet="true" charset="utf-8"/><meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" name="description" content="前端工程师，爱折腾，擅长 JavaScript，欢迎关注我的公众号「自然醒的笔记本」"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/>
<title data-react-helmet="true">什么是 LFU 算法？ · 自然醒的博客</title>
<link data-react-helmet="true" rel="stylesheet" href="/assets/index.css"/><link data-react-helmet="true" id="prismTheme" rel="stylesheet" href="/assets/prism.css"/>
<script data-react-helmet="true" >
    const shouldSetIsDark = document.cookie.includes('is_dark=1') ? true : document.cookie.includes('is_dark=0') ? false : window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (shouldSetIsDark) {
      document.documentElement.classList.add('is_dark');
      document.getElementById('prismTheme').href = "/assets/prism_tomorrow.css";
    }
  </script>
</head><body><a class="czs-menu-l show_on_mobile aside_button_open" href="#" style="background-image:url(&quot;/assets/czs-menu-l.svg&quot;)"></a><a class="show_on_mobile aside_button_text" href="/">自然醒的博客</a><aside class="hide_on_mobile"><div class="aside_card"><a class="czs-menu-l show_on_mobile aside_button_close" href="#" style="background-image:url(&quot;/assets/czs-close-l.svg&quot;)"></a><h1><a href="/">自然醒的博客</a></h1><p class="description">前端工程师，爱折腾，擅长 JavaScript，欢迎关注我的公众号「自然醒的笔记本」</p><ul class="social list_style_none"><li class="flex_center"><a class="czs-github-logo" href="https://github.com/Shenfq" target="_blank" style="background-image:url(&quot;/assets/czs-github-logo.svg&quot;)"></a></li><li class="flex_center"><a class="czs-message-l" href="mailto:shenfq95@foxmail.com" target="_blank" style="background-image:url(&quot;/assets/czs-message-l.svg&quot;)"></a></li><li style="flex-grow:1"></li><li class="toggle_dark flex_center"><span class="czs-sun" style="background-image:url(&quot;/assets/czs-sun.svg&quot;)"></span><span class="czs-sun-l" style="background-image:url(&quot;/assets/czs-sun-l.svg&quot;)"></span><span class="czs-moon" style="background-image:url(&quot;/assets/czs-moon.svg&quot;)"></span><span class="czs-moon-l" style="background-image:url(&quot;/assets/czs-moon-l.svg&quot;)"></span></li></ul><nav><ul class="menu list_style_none"><li><a class="flex_center" href="/"><span class="czs-home-l" style="background-image:url(&quot;/assets/czs-home-l.svg&quot;)"></span>首页</a></li><li><a class="flex_center" href="/categories/"><span class="czs-category-l" style="background-image:url(&quot;/assets/czs-category-l.svg&quot;)"></span>分类</a></li><li><a class="flex_center" href="/tags/"><span class="czs-tag-l" style="background-image:url(&quot;/assets/czs-tag-l.svg&quot;)"></span>标签</a></li><li><a class="flex_center" href="/about/"><span class="czs-about-l" style="background-image:url(&quot;/assets/czs-about-l.svg&quot;)"></span>关于</a></li><li><a class="flex_center" href="/archives/"><span class="czs-box-l" style="background-image:url(&quot;/assets/czs-box-l.svg&quot;)"></span>归档</a></li><li><a class="flex_center" href="/links/index.html"><span class="czs-link-l" style="background-image:url(&quot;/assets/czs-link-l.svg&quot;)"></span>友情链接</a></li></ul></nav></div><nav class="toc"><ol><li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a></li></ol></nav></aside><section class="main"><h1>什么是 LFU 算法？</h1><div class="main_post_meta"><time dateTime="2022/03/22">2022-03-22</time> · <!-- -->shenfq</div><article><p>上次的文章介绍了 LRU 算法，今天打算来介绍一下 LFU 算法。在上篇文章中有提到， LFU（<code>Least frequently used</code>：最少使用）算法与 LRU 算法只是在淘汰策略上有所不同，LRU 倾向于保留最近有使用的数据，而 LFU 倾向于保留使用频率较高的数据。</p>
<p>举一个简单的🌰：缓存中有 A、B 两个数据，且已达到上限，如果 <code>数据 A</code> 先被访问了 10 次，然后 <code>数据 B</code> 被访问 1 次，当存入新的 <code>数据 C</code> 时，如果当前是 LRU 算法，会将 <code>数据 A</code> 淘汰，而如果是 LFU 算法，则会淘汰 <code>数据 B</code>。</p>
<p>简单来说，就是在 LRU 算法中，不管访问的频率，只要最近访问过，就不会将这个数据淘汰，而在 LFU 算法中，将访问的频率作为权重，只要访问频率越高，该数据就越不会被淘汰，即使该数据很久没有被访问过。</p>
<h2 id="%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现<a class="anchor" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">§</a></h2>
<p>我们还是通过一段 JavaScript 代码来实现这个逻辑。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">{</span>
	freqs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 用于标记访问频率</span>
	cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 用于缓存所有数据</span>
	capacity <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 缓存的最大容量</span>
	<span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 存储 LFU 可缓存的最大容量</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">capacity</span> <span class="token operator">=</span> capacity
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>与 LRU 算法一样，LFU 算法也需要实现 <code>get</code> 与 <code>put</code> 两个方法，用于获取缓存和设置缓存。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取缓存</span>
	<span class="token function">get</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token comment">// 设置缓存</span>
	<span class="token function">put</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>老规矩，先看设置缓存的部分。如果该缓存的 key 之前存在，需要更新其值。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache 作为缓存的存储对象</span>
  <span class="token comment">// 其解构为: { key: { freq: 0, value: '' } }</span>
  <span class="token comment">// freq 表示该数据读取的频率；</span>
  <span class="token comment">// value 表示缓存的数据；</span>
	cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// fregs 用于存储缓存数据的频率</span>
  <span class="token comment">// 其解构为: { 0: [a], 1: [b, c], 2: [d] }</span>
  <span class="token comment">// 表示 a 还没被读取，b/c 各被读取1次，d被读取2次</span>
  freqs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 设置缓存</span>
  <span class="token function">put</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先判断缓存是否存在</span>
    <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果存在，则重置缓存的值</span>
      cache<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value
      <span class="token comment">// 更新使用频率</span>
      <span class="token keyword">let</span> <span class="token punctuation">{</span> freq <span class="token punctuation">}</span> <span class="token operator">=</span> cache
      <span class="token comment">// 从 freqs 中获取对应 key 的数组</span>
      <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span>
      <span class="token keyword">const</span> index <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token method function property-access">indexOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token comment">// 从频率数组中，删除对应的 key</span>
      keys<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果当前频率已经不存在 key</span>
        <span class="token comment">// 将 key 删除</span>
        <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 更新频率加 1</span>
      freq <span class="token operator">=</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token property-access">freq</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token comment">// 更新频率数组</span>
      <span class="token keyword">const</span> freqMap <span class="token operator">=</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      freqMap<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
      <span class="token keyword control-flow">return</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>如果该缓存不存在，要先判断缓存是否超过容量，如果超过，需要淘汰掉使用频率最低的数据。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新频率</span>
  <span class="token function">active</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新使用频率</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> freq <span class="token punctuation">}</span> <span class="token operator">=</span> cache
    <span class="token comment">// 从 freqs 中获取对应 key 的数组</span>
    <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token method function property-access">indexOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 从频率数组中，删除对应的 key</span>
    keys<span class="token punctuation">.</span><span class="token method function property-access">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果当前频率已经不存在 key</span>
      <span class="token comment">// 将 key 删除</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新频率加 1</span>
    freq <span class="token operator">=</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token property-access">freq</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment">// 更新读取频率数组</span>
    <span class="token keyword">const</span> freqMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>freq<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    freqMap<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 设置缓存</span>
  <span class="token function">put</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先判断缓存是否存在</span>
    <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果存在，则重置缓存的值</span>
      cache<span class="token punctuation">.</span><span class="token property-access">value</span> <span class="token operator">=</span> value
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">active</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> cache<span class="token punctuation">)</span>
      <span class="token keyword control-flow">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断缓存是否超过容量</span>
    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">)</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 超过存储大小，删除访问频率最低的数据</span>
      <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> keys <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>first<span class="token punctuation">]</span>
      <span class="token keyword">const</span> latest <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token method function property-access">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>latest<span class="token punctuation">]</span>
      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span>latest<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 写入缓存，默认频率为0，表示还未使用过</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">,</span> freq<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
    <span class="token comment">// 写入读取频率数组</span>
    <span class="token keyword">const</span> freqMap <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">freqs</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    freqMap<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>实现了设置缓存的方法后，再实现获取缓存就很容易了。</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获取数据</span>
	<span class="token function">get</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword nil">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 如果 key 对应的缓存存在，更新其读取频率</span>
      <span class="token comment">// 之前已经实现过，可以直接复用</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">active</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
			<span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">cache</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
		<span class="token keyword control-flow">return</span> <span class="token keyword nil">undefined</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<hr>
<p>关于 LFU 缓存算法实现就到这里了，当然该算法一般使用双链表的形式来实现，这里的实现方式，只是为了方便理解其原理，感兴趣的话可以在网上搜索下更加高效的实现方式。</p></article></section><footer>Powered by <a href="https://github.com/xcatliu/pagic" target="_blank">Pagic</a></footer><script src="https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js"></script><script src="https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js"></script><script type="module" src="/index.js"></script></body></html>